const fs = require('fs-extra');
const YAML = require('yaml');
const path = require('path');

const SWAGGER_FILE_NAME = 'swagger'
const API_FILE_NAME = 'api'


/**
 * 
 * Used to process the openapi file generated by dot.net project. changes include:
 * - Remove undersocre in the enum values, eg change from "_12" to "12".
 * - Remove classes used for schema reference for oneOf relationships
 * - Modify CentreCode to oneOf relationships
 * 
 */
const processOpenApiFile = () => {
    const inputFile = `public/openapi/${SWAGGER_FILE_NAME}.json`; // Path to your input OpenAPI spec
    const outputFile = `public/openapi/${API_FILE_NAME}.json`; // Path to save the modified OpenAPI spec

    // Load the OpenAPI specification
    const openApiSpec = loadOpenApiSpec(inputFile);

    // Update enum values
    updateEnumValues(openApiSpec);
    console.log(`Enum values like "_23" are converted to "23".`);

    // update data example enum values
    replaceQuoteUnderscore(openApiSpec)

    //RemovePropertyFromSchema(openApiSpec, "EncryptedLotHeaderAwexData", "lotHeaderAwexData")

    //RemovePropertyFromSchema(openApiSpec, "TransmissionHeader", "classForOneOfReferencesToBeDeleted")

    //modifyCentreSchema(openApiSpec)

    // Save the modified OpenAPI spec
    saveOpenApiSpec(outputFile, openApiSpec);

    console.log('OpenAPI spec updated and saved to', outputFile);
};


// Load OpenAPI specification (swagger.json)
const loadOpenApiSpec = (filePath) => {
    return fs.readJsonSync(filePath);
};

// Save OpenAPI spec back to file
const saveOpenApiSpec = (filePath, openApiSpec) => {
    fs.writeJsonSync(filePath, openApiSpec, { spaces: 2 });
};


/**
 * 
 * Processing enum values that are generated as "_34", should change it into "34" 
 * 
 */
// Update enum values
const updateEnumValues = (openApiSpec) => {
    // Traverse all schemas
    if (openApiSpec.components && openApiSpec.components.schemas) {
        const schemas = openApiSpec.components.schemas;
        for (const schemaName in schemas) {
            const schema = schemas[schemaName];
            // Check for enums
            if (schema.enum) {
                console.log(schema.enum)
                schema.enum = schema.enum.map(value => {
                    if (`${value}`.startsWith('_')) {
                        console.log(schema.enum)
                        return `${value}`.substring(1); // Remove the leading '_'
                    }
                    return value;
                });
            }
            // Recursively check properties and items
            updateEnumValuesInSchema(schema);
        }
    }
};

// Recursively update enum values in schema properties and items
const updateEnumValuesInSchema = (schema) => {
    if (schema.properties) {
        for (const key in schema.properties) {
            updateEnumValues(schema.properties[key]);
        }
    }
    if (schema.items) {
        updateEnumValues(schema.items);
    }
    if (schema.oneOf || schema.anyOf || schema.allOf) {
        const subSchemas = schema.oneOf || schema.anyOf || schema.allOf;
        subSchemas.forEach(subSchema => updateEnumValues(subSchema));
    }
};


function replaceQuoteUnderscore(jsonObj) {
    // Helper function to recursively traverse and replace '"_' with '"'
    function recursiveReplace(obj) {
        if (typeof obj === 'object' && obj !== null) {
            if (Array.isArray(obj)) {
                // If it's an array, process each element
                return obj.map(recursiveReplace);
            } else {
                // If it's an object, process its keys and values
                const newObj = {};
                for (let key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        // Replace '"_' with '"' in the key
                        let newKey = key.replace(/"_/g, '"');
                        // Process the value recursively
                        newObj[newKey] = recursiveReplace(obj[key]);
                    }
                }
                return newObj;
            }
        } else if (typeof obj === 'string') {
            // If the value is a string, replace '"_' with '"'
            return obj.replace(/"_/g, '"');
        }
        return obj; // For other types (numbers, booleans, etc.), return as is
    }

    return recursiveReplace(jsonObj);
}


/**
 * 
 * Remove property from Schema by providing the shcemaName and propertyName
 * 
 * 
 */
const RemovePropertyFromSchema = (openApiSpec, schemaName, propertyName) => {
    
    if (openApiSpec.components && openApiSpec.components.schemas) {
        const schemas = openApiSpec.components.schemas;
        
        if (schemas[schemaName]) {
            const schema = schemas[schemaName];
            
            if (schema.properties && schema.properties[propertyName]) {
                delete schema.properties[propertyName];
                console.log(`Property "${propertyName}" removed from schema "${schemaName}".`);
            } else {
                console.log(`Property "${propertyName}" not found in schema "${schemaName}".`);
            }
        } else {
            console.log(`Schema "${schemaName}" not found.`);
        }
    } else {
        console.log('No schemas found in the OpenAPI specification.');
    }
}




/**
 * 
 * Convert CentreCode into oneOf different Centres
 * 
 * 
 */
const modifyCentreSchema = (openApiSpec) => {
    const schemaName = 'Centre';

    if (openApiSpec.components && openApiSpec.components.schemas) {
        const schemas = openApiSpec.components.schemas;

        if (schemas[schemaName]) {
            const schema = schemas[schemaName];

            // Extract the properties
            const { properties } = schema;

            if (properties) {
                // Create the new centreCode property with oneOf
                const newCentreCodeProperty = {
                    oneOf: [
                        { "$ref": "#/components/schemas/CentreCodeAustralia" },
                        { "$ref": "#/components/schemas/CentreCodeChina" },
                        { "$ref": "#/components/schemas/CentreCodeGermany" },
                        { "$ref": "#/components/schemas/CentreCodeItaly" },
                        { "$ref": "#/components/schemas/CentreCodeNewZealand" },
                        { "$ref": "#/components/schemas/CentreCodeTaiwan" }
                    ]
                };

                // Replace the existing properties
                schema.properties = {
                    country: properties.country,
                    centreCode: newCentreCodeProperty
                };
                
                console.log(`Schema "${schemaName}" modified successfully.`);
            } else {
                console.log(`No properties found in schema "${schemaName}".`);
            }
        } else {
            console.log(`Schema "${schemaName}" not found.`);
        }
    } else {
        console.log('No schemas found in the OpenAPI specification.');
    }
}




/**
 * Generate individual openapi files by endpoints in both json and yaml format
 * 
 */
const generateOpenApiFilesByEndpoints = () => {
    const inputFile = `public/openapi/${API_FILE_NAME}.json`; // Path to your input OpenAPI spec
    const outputDir = 'public/openapi'; // Directory to save the output files
    const endpointGroups = {
        'catalogues': 'catalogues',
        'test-certificates': 'test-certificates',
        'dark-and-medullated-fibre-risk-verifications': 'dark-and-medullated-fibre-risk-verifications',
        'delivery-order-shipping-instructions': 'delivery-order-shipping-instructions',
        'lot-invoices': 'lot-invoices',
        'lot-price-and-buyers': 'lot-price-and-buyers',
        'payment-advices': 'payment-advices',
        'payment-confirmations': 'payment-confirmations',
        'organisation-details': 'organisation-details',
        'test-certificate-updates': 'test-certificate-updates',
        'test-certificate-requests': 'test-certificate-requests',
        'test-requests-verifications': 'test-requests-verifications',
        'test-status': 'test-status',
        'statements': 'statements',
        'postsale-printing-of-presale-certificates':'postsale-printing-of-presale-certificates',
        'texts':'texts',
    };

    // Create output directory if it doesn't exist
    fs.ensureDirSync(outputDir);

    // Load the OpenAPI specification
    const openApiSpec = loadOpenApiSpec(inputFile);

    // Get all schemas
    const allSchemas = openApiSpec.components?.schemas || {};

    // Process each endpoint group
    for (const [groupName, baseFileName] of Object.entries(endpointGroups)) {
        const filteredPaths = filterPathsByGroup(openApiSpec, groupName);

        // Extract schemas used in filtered paths, including nested references
        const usedSchemas = extractUsedSchemas(filteredPaths, allSchemas);

        const filteredOpenApiSpec = createOpenApiDocument(openApiSpec, filteredPaths, usedSchemas);

        // Save as JSON
        saveOpenApiSpecJson(outputDir, `${baseFileName}.json`, filteredOpenApiSpec);

        // Save as YAML
        saveOpenApiSpecYaml(outputDir, `${baseFileName}.yaml`, filteredOpenApiSpec);
    }
};


// Filter paths by group
const filterPathsByGroup = (openApiSpec, groupName) => {
    const filteredPaths = {};
    for (const [path, pathItem] of Object.entries(openApiSpec.paths)) {
        if (path.includes(groupName)) {
            filteredPaths[path] = pathItem;
        }
    }
    return filteredPaths;
};

// Recursively extract all referenced schemas
const extractReferencedSchemas = (schema, allSchemas, usedSchemas) => {
    if (schema.$ref) {
        const ref = schema.$ref;
        const schemaName = ref.split('/').pop();
        if (allSchemas[schemaName] && !usedSchemas[schemaName]) {
            usedSchemas[schemaName] = allSchemas[schemaName];
            // Recursively check for nested references
            extractReferencedSchemas(allSchemas[schemaName], allSchemas, usedSchemas);
        }
    } else if (schema.properties) {
        for (const key of Object.keys(schema.properties)) {
            extractReferencedSchemas(schema.properties[key], allSchemas, usedSchemas);
        }
    } else if (schema.items) {
        extractReferencedSchemas(schema.items, allSchemas, usedSchemas);
    } else if (schema.oneOf || schema.anyOf || schema.allOf) {
        const subSchemas = schema.oneOf || schema.anyOf || schema.allOf;
        subSchemas.forEach(subSchema => extractReferencedSchemas(subSchema, allSchemas, usedSchemas));
    }
};

// Extract schemas used in filtered paths
const extractUsedSchemas = (filteredPaths, allSchemas) => {
    const usedSchemas = {};
    Object.values(filteredPaths).forEach(pathItem => {
        Object.values(pathItem).forEach(operation => {
            if (operation.requestBody && operation.requestBody.content) {
                Object.values(operation.requestBody.content).forEach(content => {
                    if (content.schema) {
                        extractReferencedSchemas(content.schema, allSchemas, usedSchemas);
                    }
                });
            }
            if (operation.responses) {
                Object.values(operation.responses).forEach(response => {
                    if (response.content) {
                        Object.values(response.content).forEach(content => {
                            if (content.schema) {
                                extractReferencedSchemas(content.schema, allSchemas, usedSchemas);
                            }
                        });
                    }
                });
            }
        });
    });
    return usedSchemas;
};

// Create OpenAPI document with filtered paths and schemas
const createOpenApiDocument = (openApiSpec, filteredPaths, schemas) => {
    if (openApiSpec.components && openApiSpec.components.securitySchemes) {
        return {
            ...openApiSpec,
            paths: filteredPaths,
            components: {
                schemas: schemas,
                securitySchemes: openApiSpec.components.securitySchemes,
            },
        };
    }

    return {
        ...openApiSpec,
        paths: filteredPaths,
        components: {
            schemas: schemas,
        },
    };
};

// Save OpenAPI spec to JSON file
const saveOpenApiSpecJson = (outputDir, fileName, openApiSpec) => {
    const outputPath = path.join(outputDir, fileName);
    fs.writeJsonSync(outputPath, openApiSpec, { spaces: 2 });
};

// Save OpenAPI spec to YAML file
const saveOpenApiSpecYaml = (outputDir, fileName, openApiSpec) => {
    const outputPath = path.join(outputDir, fileName);
    const yamlData = YAML.stringify(openApiSpec, { indent: 2 });
    fs.writeFileSync(outputPath, yamlData, 'utf8');
};









const main = () =>{
    processOpenApiFile()
    generateOpenApiFilesByEndpoints()

}

main()